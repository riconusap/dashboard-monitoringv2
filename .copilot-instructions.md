# Copilot Instructions for Vue 3 Admin Starter Kit

## Project Overview
This is a Vue 3 Admin Starter Kit with Dashboard and User Management functionality. It's built with modern technologies including Vue 3, TypeScript, Vite, Pinia, and Bootstrap 5.

## Tech Stack & Dependencies
- **Vue 3** with Composition API and `<script setup>` syntax
- **TypeScript** for type safety
- **Vite** as build tool
- **Vue Router** for routing
- **Pinia** for state management
- **Bootstrap 5** for UI framework
- **ApexCharts** for data visualization
- **Element Plus** for additional UI components
- **VeeValidate** for form validation
- **Axios** for HTTP requests
- **Animate.css** for animations
- **FontAwesome** and **Bootstrap Icons** for icons

## Code Patterns & Standards

### 1. Component Structure
Use Vue 3 Composition API with TypeScript. Follow this pattern:

```vue
<template>
  <!-- Template content with proper Bootstrap classes -->
  <div class="card">
    <div class="card-header">
      <h3 class="card-title">{{ title }}</h3>
    </div>
    <div class="card-body">
      <!-- Content -->
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, computed, onMounted } from "vue";
import { useRouter } from "vue-router";
import { useAuthStore } from "@/stores/auth";

export default defineComponent({
  name: "component-name",
  props: {
    title: {
      type: String,
      required: true,
    },
    widgetClasses: String,
  },
  emits: ["update", "change"],
  setup(props, { emit }) {
    const router = useRouter();
    const authStore = useAuthStore();
    
    // Reactive state
    const loading = ref(false);
    const data = ref([]);
    
    // Computed properties
    const isAuthenticated = computed(() => authStore.isAuthenticated);
    
    // Methods
    const handleSubmit = () => {
      emit("update", data.value);
    };
    
    // Lifecycle
    onMounted(() => {
      // Initialization logic
    });
    
    return {
      loading,
      data,
      isAuthenticated,
      handleSubmit,
    };
  },
});
</script>
```

### 2. Store Pattern (Pinia)
Use Pinia stores with composition API:

```typescript
import { ref, computed } from "vue";
import { defineStore } from "pinia";
import ApiService from "@/core/services/ApiService";

export interface User {
  id: number;
  name: string;
  email: string;
}

export const useUserStore = defineStore("user", () => {
  const users = ref<User[]>([]);
  const loading = ref(false);
  
  const totalUsers = computed(() => users.value.length);
  
  const fetchUsers = async () => {
    loading.value = true;
    try {
      const response = await ApiService.get("users");
      users.value = response.data;
    } catch (error) {
      console.error("Failed to fetch users:", error);
    } finally {
      loading.value = false;
    }
  };
  
  return {
    users,
    loading,
    totalUsers,
    fetchUsers,
  };
});
```

### 3. Routing Pattern
Follow the nested routing structure:

```typescript
import { createRouter, createWebHistory } from "vue-router";

const routes = [
  {
    path: "/",
    component: () => import("@/layouts/default-layout/DefaultLayout.vue"),
    meta: { middleware: "auth" },
    children: [
      {
        path: "/dashboard",
        name: "dashboard",
        component: () => import("@/views/Dashboard.vue"),
        meta: { pageTitle: "Dashboard" },
      },
      // More routes...
    ],
  },
];
```

### 4. Service Pattern
Use centralized API services:

```typescript
import ApiService from "@/core/services/ApiService";

class UserService {
  static async getUsers(): Promise<User[]> {
    return ApiService.get("users");
  }
  
  static async createUser(user: Partial<User>): Promise<User> {
    return ApiService.post("users", user);
  }
  
  static async updateUser(id: number, user: Partial<User>): Promise<User> {
    return ApiService.put(`users/${id}`, user);
  }
  
  static async deleteUser(id: number): Promise<void> {
    return ApiService.delete(`users/${id}`);
  }
}

export default UserService;
```

## Project Structure Rules

### Directories
- `src/components/` - Reusable UI components
  - `cards/` - Card components
  - `widgets/` - Dashboard widgets (charts, tables, stats)
  - `dropdown/` - Dropdown components
  - `modals/` - Modal components
- `src/layouts/` - Layout components (DefaultLayout, AuthLayout)
- `src/views/` - Page components
- `src/stores/` - Pinia stores
- `src/core/` - Core utilities, services, plugins
- `src/assets/` - Static assets (SCSS, icons, utilities)

### File Naming
- Components: PascalCase (e.g., `UserList.vue`, `Widget12.vue`)
- Views: PascalCase (e.g., `Dashboard.vue`, `CustomerDetails.vue`)
- Stores: camelCase (e.g., `auth.ts`, `user.ts`)
- Services: PascalCase (e.g., `ApiService.ts`, `UserService.ts`)

## CSS & Styling Guidelines

### Bootstrap 5 Classes
Use Bootstrap 5 utility classes extensively:
- Layout: `d-flex`, `justify-content-*`, `align-items-*`
- Spacing: `p-*`, `m-*`, `pt-*`, `mb-*`
- Typography: `fs-*`, `fw-*`, `text-*`
- Colors: `text-primary`, `bg-light`, `text-muted`

### Card Components
Standard card structure:
```html
<div class="card">
  <div class="card-header border-0 pt-5">
    <h3 class="card-title align-items-start flex-column">
      <span class="card-label fw-bold fs-3 mb-1">Title</span>
      <span class="text-muted mt-1 fw-semibold fs-7">Subtitle</span>
    </h3>
  </div>
  <div class="card-body py-3">
    <!-- Content -->
  </div>
</div>
```

### Widget Components
Widget components should accept these props:
- `widgetClasses?: string` - Additional CSS classes
- `chartColor?: string` - Chart color theme
- `chartHeight?: string` - Chart height

## ApexCharts Integration

### Chart Components
For chart widgets, follow this pattern:

```vue
<template>
  <div class="card">
    <div class="card-body">
      <apexchart
        ref="chartRef"
        :type="chartType"
        :options="chart"
        :series="series"
        :height="chartHeight"
      />
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, computed, onBeforeMount, watch } from "vue";
import { useThemeStore } from "@/stores/theme";
import type { ApexOptions } from "apexcharts";
import type VueApexCharts from "vue3-apexcharts";
import { getCSSVariableValue } from "@/assets/ts/_utils";

export default defineComponent({
  props: {
    chartHeight: { type: String, default: "200px" },
    chartColor: String,
  },
  setup(props) {
    const chartRef = ref<typeof VueApexCharts | null>(null);
    const chart = ref<ApexOptions>({});
    const store = useThemeStore();
    
    const themeMode = computed(() => store.mode);
    
    onBeforeMount(() => {
      initChart();
    });
    
    watch(themeMode, () => {
      refreshChart();
    });
    
    const initChart = () => {
      chart.value = {
        // Chart configuration
      };
    };
    
    const refreshChart = () => {
      if (chartRef.value) {
        chartRef.value.updateOptions(chart.value);
      }
    };
    
    return { chartRef, chart };
  },
});
</script>
```

## Icon Usage

### KTIcon Component
Use the custom KTIcon component for KeenThemes icons:
```vue
<KTIcon icon-name="plus" icon-class="fs-2" />
<KTIcon icon-name="arrow-right" icon-class="fs-3 text-primary" />
```

### Bootstrap Icons
For Bootstrap icons:
```html
<i class="bi bi-plus fs-2"></i>
<i class="bi bi-arrow-right fs-3 text-primary"></i>
```

## Form Handling

### VeeValidate Integration
```vue
<template>
  <Form @submit="onSubmit" :validation-schema="schema">
    <div class="mb-3">
      <label class="form-label">Email</label>
      <Field
        name="email"
        type="email"
        class="form-control"
        placeholder="Enter email"
      />
      <ErrorMessage name="email" class="text-danger" />
    </div>
    <button type="submit" class="btn btn-primary">Submit</button>
  </Form>
</template>

<script lang="ts">
import { Form, Field, ErrorMessage } from "vee-validate";
import * as yup from "yup";

const schema = yup.object({
  email: yup.string().email().required(),
});
</script>
```

## Authentication & Routing

### Route Guards
Use the auth middleware for protected routes:
```typescript
{
  path: "/dashboard",
  component: Dashboard,
  meta: {
    middleware: "auth",
    pageTitle: "Dashboard",
  },
}
```

### Auth Store Usage
```typescript
import { useAuthStore } from "@/stores/auth";

const authStore = useAuthStore();
const isAuthenticated = computed(() => authStore.isAuthenticated);
```

## Data Tables

### KTDataTable Component
Use the custom datatable component:
```vue
<template>
  <Datatable
    :table-header="tableHeader"
    :table-data="tableData"
    :rows-per-page="10"
    :enable-items-per-page-dropdown="true"
    @on-sort="sort"
    @on-items-select="onItemSelect"
  >
    <template v-slot:cell-actions="{ row }">
      <button @click="editItem(row)" class="btn btn-sm btn-primary">
        Edit
      </button>
    </template>
  </Datatable>
</template>
```

## Menu Configuration

### Adding Menu Items
Update `MainMenuConfig.ts`:
```typescript
{
  heading: "newPage",
  route: "/new-page",
  keenthemesIcon: "abstract-39",
  bootstrapIcon: "bi-house",
}
```

## Development Guidelines

### Type Safety
- Always use TypeScript interfaces for data models
- Define proper prop types and return types
- Use generic types for reusable components

### Performance
- Use `v-memo` for expensive list rendering
- Implement lazy loading for routes
- Use `computed` for derived state
- Prefer `readonly` for immutable data

### Error Handling
- Wrap async operations in try-catch blocks
- Display user-friendly error messages
- Use consistent error state management

### Testing
- Write unit tests for utilities and services
- Use Vue Test Utils for component testing
- Mock API calls in tests

## Common Patterns

### Loading States
```vue
<template>
  <div v-if="loading" class="d-flex justify-content-center">
    <div class="spinner-border" role="status"></div>
  </div>
  <div v-else>
    <!-- Content -->
  </div>
</template>
```

### Empty States
```vue
<template>
  <div v-if="!items.length" class="text-center py-10">
    <KTIcon icon-name="files" icon-class="fs-1 text-muted mb-3" />
    <h4 class="text-muted">No items found</h4>
  </div>
</template>
```

### Modal Usage
```vue
<template>
  <div class="modal fade" tabindex="-1">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Modal Title</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
        </div>
        <div class="modal-body">
          <!-- Content -->
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
            Cancel
          </button>
          <button type="button" class="btn btn-primary">
            Save
          </button>
        </div>
      </div>
    </div>
  </div>
</template>
```

## Code Quality Standards

1. **Consistent naming**: Use descriptive names for variables, functions, and components
2. **Single responsibility**: Each component should have one clear purpose
3. **DRY principle**: Avoid code duplication, create reusable utilities
4. **Accessibility**: Use proper ARIA labels and semantic HTML
5. **Performance**: Optimize bundle size and runtime performance
6. **Security**: Sanitize user inputs and use proper authentication

## When Adding New Features

1. **Components**: Create in appropriate subdirectory under `/components/`
2. **Views**: Add to `/views/` with proper route configuration
3. **Stores**: Create focused stores for specific features
4. **Types**: Define TypeScript interfaces in appropriate files
5. **Styling**: Use Bootstrap classes first, custom SCSS as needed
6. **Testing**: Add tests for complex logic and critical paths

Follow these patterns and guidelines to maintain consistency and quality throughout the codebase.